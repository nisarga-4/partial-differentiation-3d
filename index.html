<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Partial Differentiation – 3D Visualization</title>
  <style>
    body {
      margin: 0;
      background: #0f172a;
      color: white;
      font-family: Arial, sans-serif;
      text-align: center;
    }
    h1 {
      margin-top: 15px;
    }
    canvas {
      display: block;
    }
    p {
      color: #cbd5f5;
    }
  </style>
</head>
<body>

<h1>3D Partial Differentiation</h1>
<p>Surface: z = x² + y²</p>
  <p style="position:absolute;top:60px;left:10px;color:red;">∂z/∂x</p>
<p style="position:absolute;top:80px;left:10px;color:green;">∂z/∂y</p>

<script  src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>

<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f172a);

  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(6, 6, 6);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; // smooth rotation
  controls.dampingFactor = 0.05;

  // Light
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 7);
  scene.add(light);

  // Surface Geometry z = x^2 + y^2
  const geometry = new THREE.PlaneGeometry(6, 6, 50, 50);
  const vertices = geometry.attributes.position;
  for (let i = 0; i < vertices.count; i++) {
    const x = vertices.getX(i);
    const y = vertices.getY(i);
    const z = (x*x + y*y)/4;
    vertices.setZ(i, z);
  }
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({
    color: 0x38bdf8,
    side: THREE.DoubleSide,
    wireframe: false
  });

  const surface = new THREE.Mesh(geometry, material);
  surface.rotation.x = -Math.PI/2;
  scene.add(surface);

  // Partial derivatives arrows
  const arrowHelperX = new THREE.ArrowHelper(
    new THREE.Vector3(1, 0, 0), // direction
    new THREE.Vector3(0,0,0),   // origin
    2,                          // length
    0xff0000                    // color red
  );
  scene.add(arrowHelperX);

  const arrowHelperY = new THREE.ArrowHelper(
    new THREE.Vector3(0, 1, 0),
    new THREE.Vector3(0,0,0),
    2,
    0x00ff00 // green
  );
  scene.add(arrowHelperY);

  function animate() {
    requestAnimationFrame(animate);
    controls.update(); // update controls
    renderer.render(scene, camera);
  }
  animate();

  // Handle window resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
  

</body>
</html>
